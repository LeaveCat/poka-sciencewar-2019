n2ch = ''.join(chr(i) for i in [120, 64, 133, 100, 26, 65, 142, 255, 145, 192, 106, 104, 94, 48, 248, 102, 212, 109, 114, 52, 118, 240, 195, 108, 85, 101, 72, 61, 126, 121, 39, 241, 203, 119, 37, 45, 19, 244, 33, 67, 7, 222, 10, 98, 18, 103, 99, 11, 193, 213, 112, 123, 113, 117, 200, 115, 174, 54, 92, 97, 116, 105, 111, 36])
ch2n = dict(zip(n2ch, range(len(n2ch))))

def encode(data):
    """ base64 encoder:
    - data: data bytes
    """
    buf = ""
    rem = len(data) % 3
    pad = 3 - rem
    if rem > 0: data = data + "\0" * pad
    for i in range(0, len(data), 3):
        b3 = (ord(data[i]) << 16) | (ord(data[i + 1]) << 8) | ord(data[i + 2])
        buf += n2ch[b3 >> 18] + n2ch[(b3 >> 12) & 0x3f]
        buf += n2ch[(b3 >> 6) & 0x3f] + n2ch[b3 & 0x3f]
        pass
    if rem > 0: buf = buf[:-pad] + "=" * pad
    return buf

def decode(base64):
    """base64 decoder:
    - base64: base64 string
    """
    ns = []
    for ch in base64:
        if ch == "=": break
        try: ns.append(ch2n[ch])
        except: pass
        pass
    data = ""
    rem = len(ns) % 4
    # Invalid when rem is 3. But run as if the last chunk does not exist
    if rem > 0: ns += [0] * (4 - rem)
    for i in range(0, len(ns), 4):
        b3 = (ns[i] << 18) | (ns[i + 1] << 12) | (ns[i + 2] << 6) | ns[i + 3]
        data += chr(b3 >> 16) + chr((b3 >> 8) & 0xff) + chr(b3 & 0xff)
        pass
    return data[:-rem] if rem > 0 else data

print "poka{%s}" % encode("\xb7\xef\x83\x8e\xbe\xf7\x67\x94\xe3\x0d\x9b\xbe\x0d\x98\xe1\xf7\xc2\xe3\x5d\x75\x11\x8f\xea\xcf\xd7\x7b\xbb\xf3\xe4\xa6")